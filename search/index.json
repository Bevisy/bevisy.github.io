[{"content":"临时关闭 sudo dphys-swapfile swapoff 永久关闭 sudo systemctl disable dphys-swapfile.service --now # 注释fstab #/dev/mapper/vgubuntu-swap_1 none swap sw 0 0 ","date":"2021-05-25T13:55:24+08:00","permalink":"https://bevisy.github.io/p/close-swap-on-ubuntu20.04/","title":"Close Swap on Ubuntu20.04"},{"content":"linux 利用loop设备模拟块设备 创建虚拟设备 losetup --help -a 显示所有已经使用的回环设备状态 -d 卸除回环设备 -f 寻找第一个未使用的回环设备 -e \u0026lt;加密选项\u0026gt; 启动加密编码 # 查找第一个未使用的回环设备 losetup -f # 创建文件 dd if=/dev/zero of=./disk.img bs=4M count=1024 # 将disk.img 虚拟成一个回环设备 losetup -f disk.img # 查询此设备 losetup -a | grep disk.img /dev/loop25: [64768]:3296700 (/home/zbb/temp/disk/disk.img) # 格式化设备 mkfs.ext4 /dev/loop25 # 挂载块设备 mount /dev/loop25 test # test 为自定义目录 # 卸载设备 umount test losetup -d /dev/loop25 ","date":"2021-04-02T16:37:51+08:00","permalink":"https://bevisy.github.io/p/uncanny-skills/","title":"Uncanny Skills"},{"content":"基于ZFS的Ubuntu20.04安装kubernetes1.20 containerd 安装 containerd containerd.io 1.4.3 269548fa27e0089a8b8278fc4fc781d7f65a939b 安装 # 安装必要组件 $ sudo apt-get update $ sudo apt-get install \\  apt-transport-https \\  ca-certificates \\  curl \\  gnupg-agent \\  software-properties-common # 安装gpg key curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - # 验证gpg key $ sudo apt-key fingerprint 0EBFCD88 # 添加 repo $ sudo add-apt-repository \\  \u0026#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs)\\ stable\u0026#34; # 安装containerd $ sudo apt-get update $ sudo apt-get install containerd.io 安装参考\n配置修改适配 zfs 查看 zfs 插件\n$ sudo ctr plugins ls | grep zfs io.containerd.snapshotter.v1 zfs linux/amd64 ok 准备config.toml\n$ sudo cp /etc/containerd/config.toml /etc/containerd/config.toml.bk $ sudo chmod 646 /etc/containerd/config.toml $ sudo containerd config default \u0026gt; /etc/containerd/config.toml 修改snapshotter为zfs\n[plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.containerd] #snapshotter = \u0026#34;overlayfs\u0026#34; snapshotter = \u0026#34;zfs\u0026#34; 重启containerd，containerd不支持配置热加载\n$ sudo systemctl restart containerd 挂载 zfs 到containerd指定目录 查询 pool $ sudo zpool list NAME SIZE ALLOC FREE CKPOINT EXPANDSZ FRAG CAP DEDUP HEALTH ALTROOT rpool 460G 8.64G 451G - - 0% 1% 1.00x ONLINE - 挂载目录 $ sudo zfs create -o mountpoint=/var/lib/containerd/io.containerd.snapshotter.v1.zfs rpool/containerd 查看挂载的目录 $ sudo zfs list NAME USED AVAIL REFER MOUNTPOINT ... rpool/containerd 96K 437G 96K /var/lib/containerd/io.containerd.snapshotter.v1.zfs 验证 拉取镜像 $ sudo ctr i pull --snapshotter=zfs docker.io/library/nginx:1.17 启动容器 $ sudo ctr run --rm --net-host -d --snapshotter=zfs docker.io/library/nginx:1.17 test 查看nginx启动结果 $ sudo ctr t ls TASK PID STATUS test 1494537 RUNNING $ netstat -alptn | grep 80 tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN - $ curl http://127.0.0.1:80 # 正常可访问 \u0026lt;!DOCTYPE html\u0026gt; ... \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/html\u0026gt; 待解决的问题 问题 1 非root账户，sudo权限不指定参数snapshotter创建container，提示ctr: failed to mount /tmp/containerd-mount589724034: invalid argument，无法创建容器。\n切换成root用户，依旧提示，但是容器可以正常创建\n(root)$ ctr run --rm --net-host -d docker.io/library/nginx:1.17 test ctr: failed to mount /tmp/containerd-mount589724034: invalid argument (root)$ ctr t ls TASK PID STATUS test 1494537 RUNNING kubernetes 安装 Client Version: version.Info{Major:\u0026#34;1\u0026#34;, Minor:\u0026#34;20\u0026#34;, GitVersion:\u0026#34;v1.20.1\u0026#34;, GitCommit:\u0026#34;c4d752765b3bbac2237bf87cf0b1c2e307844666\u0026#34;, GitTreeState:\u0026#34;clean\u0026#34;, BuildDate:\u0026#34;2020-12-18T12:09:25Z\u0026#34;, GoVersion:\u0026#34;go1.15.5\u0026#34;, Compiler:\u0026#34;gc\u0026#34;, Platform:\u0026#34;linux/amd64\u0026#34;} Server Version: version.Info{Major:\u0026#34;1\u0026#34;, Minor:\u0026#34;20\u0026#34;, GitVersion:\u0026#34;v1.20.1\u0026#34;, GitCommit:\u0026#34;c4d752765b3bbac2237bf87cf0b1c2e307844666\u0026#34;, GitTreeState:\u0026#34;clean\u0026#34;, BuildDate:\u0026#34;2020-12-18T12:00:47Z\u0026#34;, GoVersion:\u0026#34;go1.15.5\u0026#34;, Compiler:\u0026#34;gc\u0026#34;, Platform:\u0026#34;linux/amd64\u0026#34;} 安装 当前安装工具有很多，此处选择使用kubeadm\n准备kubernetes 源(使用阿里镜像源)，并安装必要组件 sudo apt-get update sudo apt-get install apt-transport-https curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add - sudo cat \u0026lt;\u0026lt; EOF \u0026gt;/etc/apt/sources.list.d/kubernetes.list deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main EOF sudo apt-get update sudo apt-get install kubelet kubeadm kubectl 安装完成后 kubelet 服务会处于不断重启状态，暂时不需要关注，kubelet等待连接kube-apiserver，预期现象。\n启动kubernetes集群 准备容器镜像 $ kubeadm config images list # 查看需要准备的镜像 k8s.gcr.io/coredns:1.7.0 k8s.gcr.io/etcd:3.4.13-0 k8s.gcr.io/kube-apiserver:v1.20.1 k8s.gcr.io/kube-controller-manager:v1.20.1 k8s.gcr.io/kube-proxy:v1.20.1 k8s.gcr.io/kube-scheduler:v1.20.1 k8s.gcr.io/pause:3.2 containerd 镜像加速 配置参考：\n[plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.registry] [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.registry.mirrors] [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.registry.mirrors.\u0026#34;docker.io\u0026#34;] #endpoint = [\u0026#34;https://registry-1.docker.io\u0026#34;] endpoint = [\u0026#34;https://as065r9f.mirror.aliyuncs.com\u0026#34;] 启动集群 $ sudo kubeadm init --pod-network-cidr=10.10.0.0/16 --service-cidr=10.20.0.0/16 --kubernetes-version=v1.20.1 --apiserver-advertise-address 192.168.126.246 --cri-socket /run/containerd/containerd.sock  \u0026ndash;kubernetes-version: 指定 kubernetes 版本； \u0026ndash;apiserver-advertise-address：指定 kube-apiserver 监听的ip地址； \u0026ndash;pod-network-cidr：指定 Pod 的网络范围； \u0026ndash;service-cidr：指定 Service 的网络范围； \u0026ndash;cri-socket：指定cri(社区趋势：cri 采用 containerd)  验证安装结果 # 根据提示拷贝kubeconfig文件 $ kubectl version Client Version: version.Info{Major:\u0026#34;1\u0026#34;, Minor:\u0026#34;20\u0026#34;, GitVersion:\u0026#34;v1.20.1\u0026#34;, GitCommit:\u0026#34;c4d752765b3bbac2237bf87cf0b1c2e307844666\u0026#34;, GitTreeState:\u0026#34;clean\u0026#34;, BuildDate:\u0026#34;2020-12-18T12:09:25Z\u0026#34;, GoVersion:\u0026#34;go1.15.5\u0026#34;, Compiler:\u0026#34;gc\u0026#34;, Platform:\u0026#34;linux/amd64\u0026#34;} Server Version: version.Info{Major:\u0026#34;1\u0026#34;, Minor:\u0026#34;20\u0026#34;, GitVersion:\u0026#34;v1.20.1\u0026#34;, GitCommit:\u0026#34;c4d752765b3bbac2237bf87cf0b1c2e307844666\u0026#34;, GitTreeState:\u0026#34;clean\u0026#34;, BuildDate:\u0026#34;2020-12-18T12:00:47Z\u0026#34;, GoVersion:\u0026#34;go1.15.5\u0026#34;, Compiler:\u0026#34;gc\u0026#34;, Platform:\u0026#34;linux/amd64\u0026#34;} Flannel 安装 kubernetes v1.17+ 版本\nkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 需要修改配置：\nnet-conf.json: | { \u0026#34;Network\u0026#34;: \u0026#34;10.10.0.0/16\u0026#34;, # kubeadm init 创建时使用的pod-network-cidr \u0026#34;Backend\u0026#34;: { \u0026#34;Type\u0026#34;: \u0026#34;vxlan\u0026#34; } } 参考连接\n待解决问题 containerd 一直会刷新 error 日志\nJan 11 17:49:51 zbb-sonypc containerd[1566292]: time=\u0026quot;2021-01-11T17:49:51.380076683+08:00\u0026quot; level=error msg=\u0026quot;Failed to get usage for snapshot \\\u0026quot;sha256:ffc9b21953f4cd7956cdf532a5db04ff0a2daa7475ad796f1bad58cfbaf77a07\\\u0026quot;\u0026quot; error=\u0026quot;zfs does not implement Usage() yet\u0026quot;\n参考issue\n规避办法 暂时通过修改代码规避\nbevisy/zfs bevisy/containerd\n","date":"2021-01-11T13:56:02+08:00","permalink":"https://bevisy.github.io/p/install-kubernetes1.20.1-and-containerd1.4.3-on-ubuntu-with-zfs/","title":"Install Kubernetes1.20.1 and Containerd1.4.3 on Ubuntu with ZFS"},{"content":"在Macbook上烧录iso镜像，制作操作系统盘 查看烧录U盘 diskutil list # 例如：/dev/disk3 取消挂载U盘 diskutil unmountDisk /dev/disk3 烧录 # 以 ubuntu-20.04.iso 为例 sudo dd if=~/Downloads/ubuntu-20.04.iso of=/dev/disk3 bs=1m \u0026amp;\u0026amp; sync # sync 作用: 使缓存落盘 弹出U盘 diskutil eject /dev/disk3 ","date":"2021-01-06T19:22:16+08:00","image":"https://bevisy.github.io/p/burn-the-operating-system-installation-disk-on-mac/macbook-wallpaper_hub5f1547efc25c7c1feca77e086cc842c_65753_120x120_fill_q75_box_smart1.jpg","permalink":"https://bevisy.github.io/p/burn-the-operating-system-installation-disk-on-mac/","title":"Burn the Operating System Installation Disk on Mac"},{"content":"Ubuntu 20.04 安装 Tigervncserver # 安装 $ sudo apt update $ sudo apt install xfce4 xfce4-goodies tigervnc-standalone-server # 推荐使用 xfce4 桌面 # 启动 $ vncpasswd # 配置 vnc 客户端连接密码 $ vncserver $ vncserver -kill :1 # 关闭创建的 vnc server # 修改配置，解决黑屏和灰屏问题 $ touch $HOME/.vnc/xstartup $ chmod u+x $HOME/.vnc/xstartup $ cat \u0026gt; $HOME/.vnc/xstartup \u0026lt;\u0026lt; EOF #!/bin/sh unset SESSION_MANAGER unset DBUS_SESSION_BUS_ADDRESS [ -r $HOME/.Xresources ] \u0026amp;\u0026amp; xrdb $HOME/.Xresources xsetroot -solid grey xterm -geometry 80x24+10+10 -ls -title \u0026#34;$VNCDESKTOP Desktop\u0026#34; \u0026amp; startxfce4 \u0026amp; EOF # 再次启动 $ vncserver :1 --geomotry 1366x768 # --geometry 参数随意 # 使用 vnc viewer 连接，端口号为 5091 使用 lxde 桌面 # 安装 $ sudo apt install xorg lxde-core lxterminal # 配置 vncserver 启动桌面 $ cat \u0026gt; $HOME/.vnc/xstartup \u0026lt;\u0026lt; EOF #!/bin/sh lxterminal \u0026amp; /usr/bin/lxsession -s LXDE \u0026amp; EOF ","date":"2020-07-31T11:47:14+08:00","permalink":"https://bevisy.github.io/p/install-tigervncserver-on-ubuntu-20.04/","title":"Install TigerVncServer On Ubuntu 20.04"},{"content":"Ubuntu 20.04 安装微信客户端 clone repo deepin-wine-ubuntu \n执行脚本 sudo chmod a+x install_2.8.22.sh \u0026amp;\u0026amp; ./install_2.8.22.sh\n下载微信deb包，并安装 下载地址\n安装微信： sudo dpkg –i deepin.com.wechat_2.6.8.65deepin0_i386.deb\n安装字体：(参考issue：https://github.com/wszqkzqk/deepin-wine-ubuntu/issues/253) sudo apt install fonts-wqy-microhei fonts-wqy-zenhei\n","date":"2020-07-29T11:16:31+08:00","permalink":"https://bevisy.github.io/p/install-wechat-client-on-ubuntu-20.04/","title":"Install Wechat Client On Ubuntu 20.04"},{"content":"Ubuntu 20.04 显示器分辨率模式调整 问题描述 Ubuntu 20.04 提示无法识别显示器，默认以分辨率1024x768(4:3)展示\n问题解决 添加新的分辨率模式\n查询输出接口 $ xrandr Screen 0: minimum 320 x 200, current 2624 x 900, maximum 16384 x 16384 eDP-1 connected primary 1600x900+0+0 (normal left inverted right x axis y axis) 309mm x 174mm 1600x900 60.01*+ 59.99 59.94 59.95 59.82 1440x900 59.89 ... 360x202 59.51 59.13 320x180 59.84 59.32 DP-1 disconnected (normal left inverted right x axis y axis) HDMI-1 disconnected (normal left inverted right x axis y axis) DP-2 connected 1024x768+1600+0 (normal left inverted right x axis y axis) 0mm x 0mm # 注意此行 1024x768 60.00* 800x600 60.32 56.25 848x480 60.00 640x480 59.94 HDMI-2 disconnected (normal left inverted right x axis y axis) 外界显示器输出接口为 DP-2\n生成分辨率模式并添加 $ cvt 1920 1080 # 1920x1080 59.96 Hz (CVT 2.07M9) hsync: 67.16 kHz; pclk: 173.00 MHz Modeline \u0026#34;1920x1080_60.00\u0026#34; 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync # 新建分辨率模式(可以不执行) $ sudo xrandr --newmode \u0026#34;1920x1080_60.00\u0026#34; 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync # 添加分辨率模式 $ sudo xrandr --addmode DP-2 \u0026#34;1920x1080_60.00\u0026#34; $ sudo xrandr --output DP-2 \u0026#34;1920x1080_60.00\u0026#34; 总结 这里主要是通过修改输出信号来适配外接显示器，实际上外接显示器的型号未识别。\n","date":"2020-07-27T10:24:29+08:00","permalink":"https://bevisy.github.io/p/ubuntu-20.04-%E6%98%BE%E7%A4%BA%E5%99%A8%E5%88%86%E8%BE%A8%E7%8E%87%E6%A8%A1%E5%BC%8F%E8%B0%83%E6%95%B4/","title":"Ubuntu 20.04 显示器分辨率模式调整"},{"content":"[TOC]\nkata-containers 编译安装 kata-runtime 编译安装 # download source code $ go get -d -u github.com/kata-containers/runtime $ cd ${GOPATH}/src/github.com/kata-containers/runtime # compile and install $ make $ make install # Install Dir /usr/libexec/kata-containers/kata-netmon /usr/local/bin/kata-runtime /usr/local/bin/containerd-shim-kata-v2 /usr/share/defaults/kata-containers/* kata-shim 编译安装 # download source code $ go get -d -u github.com/kata-containers/shim $ cd ${GOTAH}/src/github.com/kata-containers/shim # compile and install  $ makn $ make install # Install Dir /usr/libexec/kata-containers/kata-shim kata-proxy 编译安装 # download source code $ go get -d -u github.com/kata-containers/proxy $ cd ${GOTAH}/src/github.com/kata-containers/proxy # compile and install  $ make $ make install # Install Dir /usr/libexec/kata-containers/kata-proxy 编译 kata 所需的 kernel # download source code $ go get -d -u github.com/kata-containers/packaging $ cd ${GOTAH}/src/github.com/kata-containers/packaging/kernel $ git checkout stable-1.12 # On Ubuntu20.04 should install some essential packages $ sudo apt install -y \\ \tgcc \\ \tmake \\ \tlibncurses5-dev \\ \topenssl \\ \tlibssl-dev \\ \tbuild-essential \\ \tpkg-config \\ \tlibc6-dev \\ \tbison \\ \tflex \\ \tlibelf-dev # Also you should install yq from github: https://github.com/mikefarah/yq # 注意：如果缺少依赖，会导致内核编译所需要的 .config 文件，无法主动生成，可以将 configs/ 和 configs/fragments 目录下对应文件拼接成完整文件。 $ ./build-kernel.sh -v 5.4.60 -f -d setup # stable-1.12 支持的最新LTS内核 # compile kernel $ ./build-kernel.sh -v 5.4.60 -f -d build # Output File: ${GOPATH}/src/github.com/kata-containers/packaging/kernel/kata-linux-5.4.60-89/vmlinux # Install Dir: /usr/share/kata-containers/vmlinux 编译 agent (可选) $ go get -d -u github.com/kata-containers/agent $ cd $GOPATH/src/github.com/kata-containers/agent \u0026amp;\u0026amp; make 编译 rootfs 文件系统 # stable-1.10 方法 # Download source code $ go get -d -u github.com/kata-containers/osbuilder # generate rootfs $ export ROOTFS_DIR=${GOPATH}/src/github.com/kata-containers/osbuilder/rootfs-builder/rootfs $ sudo rm -rf ${ROOTFS_DIR} $ cd $GOPATH/src/github.com/kata-containers/osbuilder/rootfs-builder # ${distro} 需要替换成具体的系统，推荐 centos # 此处增加额外的包，是为了后续便于进入虚拟机调试 #$ script -fec \u0026#39;sudo -E GOPATH=$GOPATH USE_DOCKER=true EXTRA_PKGS=\u0026#34;bash coreutils\u0026#34; ./rootfs.sh ${distro}\u0026#39; $ script -fec \u0026#39;sudo -E GOPATH=$GOPATH USE_DOCKER=true EXTRA_PKGS=\u0026#34;bash coreutils vim net-tools procps curl iproute\u0026#34; http_proxy=http://{proxy}:{ip} https_proxy=http://{proxy}:{ip} ./rootfs.sh ${distro}\u0026#39; # 由于网络原因，可以构建时候添加 http_proxy 代理; $ script -fec \u0026#39;sudo -E GOPATH=$GOPATH USE_DOCKER=true EXTRA_PKGS=\u0026#34;bash coreutils\u0026#34; http_proxt=http://{IP}:{PORT} ./rootfs.sh ${distro}\u0026#39; # 开启vm debug（host进入vm） ## 方案一(官方文档目前的方案，支持kata-containers 1.10.7;kata-agent 1.10.7) ## 1.确保rootfs已安装 bash coreutils ## 2./etc/kata-containers/configuration.toml 配置文件修改 $ sudo sed -i -e \u0026#39;s/^kernel_params = \u0026#34;\\(.*\\)\u0026#34;/kernel_params = \u0026#34;\\1 agent.debug_console\u0026#34;/g\u0026#39; \u0026#34;${kata_configuration_file}\u0026#34; ## 3.确保配置文件的[proxy.kata] enable_debug 不为 true （默认不为true） $ sudo awk \u0026#39;{if (/^\\[proxy\\.kata\\]/) {got=1}; if (got == 1 \u0026amp;\u0026amp; /^.*enable_debug/) {print \u0026#34;#enable_debug = true\u0026#34;; got=0; next; } else {print}}\u0026#39; /etc/kata-containers/configuration.toml \u0026gt; /tmp/configuration.toml ## 4.使用 socat 访问，回车可进入bash，虚拟机刚启动会刷新大量日志，等待日志刷新完毕即可 # 方案二（之前使用的方案，也是官方方案，通过添加额外的kata-debug.service，相比方案一qemu无需传递内核参数agent.debug_console，同样确保配置文件的[proxy.kata] enable_debug 不为 true （默认不为true）） # Create a debug systemd service $ cat \u0026lt;\u0026lt;EOT | sudo tee ${ROOTFS_DIR}/lib/systemd/system/kata-debug.service [Unit] Description=Kata Containers debug console [Service] Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin StandardInput=tty StandardOutput=tty # Must be disabled to allow the job to access the real console PrivateDevices=no Type=simple ExecStart=/bin/bash Restart=always EOT # Add a dependency to start the debug console: $ sudo sed -i \u0026#39;$a Requires=kata-debug.service\u0026#39; ${ROOTFS_DIR}/lib/systemd/system/kata-containers.target # Output File: ${GOPATH}/src/github.com/kata-containers/osbuilder/rootfs-builder/rootfs # 注意事项 # 1.安全容器开启debug console后，host使用socat访问vm，访问console.sock一次只允许一个连接，如果已存在进入虚拟机的连接，则其它连接均被阻塞 # stable-1.12 # Download source code $ go get -d -u github.com/kata-containers/osbuilder $ cd $GOPATH/src/github.com/kata-containers/osbuilder # 构建rootfs mkdir -p ${PWD}/myrootfs export USE_DOCKER=true export EXTRA_PKGS=\u0026#34;vim bash coreutils vim net-tools procps curl iproute\u0026#34; export AGENT_VERSION=\u0026#34;1.12.0\u0026#34; export AGENT_SOURCE_BIN=\u0026#34;$GOPATH/src/github.com/kata-containers/agent\u0026#34; # kata-agent 二进制文件目录 export http_proxy=http://{} export https_proxy=http://{} ./rootfs-builder/rootfs.sh -r ${PWD}/myrootfs centos # 可根据需求修改 distro ## 如果出现镜像构建在下载github文件卡住，可将对应{distro}目录下的Dockerfile.in模板，直接添加上ENV proxy # 构建img # build image based rootfs created above sudo USE_DOCKER=true ./image-builder/image_builder.sh \u0026#34;${PWD}/myrootfs\u0026#34; 编译 rootfs.img # stable-1.10 方法 # make sure rootfs is not MODIFIED!!! if you want to add new Agent # install agent (optional) $ sudo install -o root -g root -m 0550 -t ${ROOTFS_DIR}/bin ../../agent/kata-agent $ sudo install -o root -g root -m 0440 ../../agent/kata-agent.service ${ROOTFS_DIR}/usr/lib/systemd/system/ $ sudo install -o root -g root -m 0440 ../../agent/kata-containers.target ${ROOTFS_DIR}/usr/lib/systemd/system/ # Compile $ cd $GOPATH/src/github.com/kata-containers/osbuilder/image-builder $ script -fec \u0026#39;sudo -E USE_DOCKER=true ./image_builder.sh ${ROOTFS_DIR}\u0026#39; # install $ commit=$(git log --format=%h -1 HEAD) $ date=$(date +%Y-%m-%d-%T.%N%z) $ image=\u0026#34;kata-containers-${date}-${commit}\u0026#34; $ sudo install -o root -g root -m 0640 -D kata-containers.img \u0026#34;/usr/share/kata-containers/${image}\u0026#34; $ (cd /usr/share/kata-containers \u0026amp;\u0026amp; sudo ln -sf \u0026#34;$image\u0026#34; kata-containers.img) # Output File: $GOPATH/src/github.com/kata-containers/osbuilder/image-builder/kata-containers.img 编译 initrd.img # make sure rootfs is not MODIFIED!!! if you want to add new Agent # install agent(optional) $ sudo install -o root -g root -m 0550 -T ../../agent/kata-agent ${ROOTFS_DIR}/sbin/init # Compile $ cd $GOPATH/src/github.com/kata-containers/osbuilder/initrd-builder $ script -fec \u0026#39;sudo -E AGENT_INIT=yes USE_DOCKER=true ./initrd_builder.sh ${ROOTFS_DIR}\u0026#39; # install $ commit=$(git log --format=%h -1 HEAD) $ date=$(date +%Y-%m-%d-%T.%N%z) $ image=\u0026#34;kata-containers-initrd-${date}-${commit}\u0026#34; $ sudo install -o root -g root -m 0640 -D kata-containers-initrd.img \u0026#34;/usr/share/kata-containers/${image}\u0026#34; $ (cd /usr/share/kata-containers \u0026amp;\u0026amp; sudo ln -sf \u0026#34;$image\u0026#34; kata-containers-initrd.img) # Output File: $GOPATH/src/github.com/kata-containers/osbuilder/initrd-builder/kata-containers-initrd.img 编译 qemu on aarch64 # 下载代码 $ go get -d github.com/kata-containers/tests # 准备依赖 $ sudo apt install -y libcap-ng-dev libglib2.0-dev libpixman-1-dev librbd-dev libattr1-dev libcap-dev # 编译构建 $ script -fec \u0026#39;sudo -E ${GOPATH}/src/github.com/kata-containers/tests/.ci/install_qemu.sh\u0026#39; # 注意：如果安装失败，清直接删除文件夹，然后重新跑升级脚本 $ sudo rm -rf ${GOPATH}/src/github.com/kata-containers/packaging # 可不操作 $ sudo rm -rf ${GOPATH}/src/github.com/qemu # 如果需要编译指定代码分支的qemu版本，需要切换tests分支，以及packaging分支为同一分支 # 由于脚本.ci/install_qemu.sh go get 获取packaging代码后未切换分支，所以需要构建失败后，手动切换分支 # 目前已知最新的版本的qemu patch是针对qemu 5.1的，并不能直接使用master代码，会导致patch合入失败 Docker 对接 kata-runtime 修改 Docker 配置文件/etc/docker/daemon.json\n{ \u0026#34;debug\u0026#34;: true, \u0026#34;default-runtime\u0026#34;: \u0026#34;runc\u0026#34;, # 可替换成 kata-runtime \u0026#34;runtimes\u0026#34;: { \u0026#34;kata\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;/usr/local/bin/kata-runtime\u0026#34; # 不支持直接配置成 containerd-shim-kata-v2 } } } 重启 docker 服务（必须）\n验证修改生效\nsudo docker run --rm --name test busybox:latest uname -a 与宿主机内核对比，验证是否生效\n调试 kata-runtime # docker 开启 debug: /etc/docker/daemon.json 添加参数 (需重启服务) { \u0026#34;debug\u0026#34;: true } # kata配置文件/etc/kata-containers/configuration.toml，开启 enable_debug # 查看日志 $ journalctl -ft kata-runtime Containerd 对接 containerd-shim-kata-v2 修改 containerd 的配置/etc/containerd/config.toml\ncontainerd config default 生成当前版本默认配置\nversion = 2 root = \u0026#34;/var/lib/containerd\u0026#34; state = \u0026#34;/run/containerd\u0026#34; plugin_dir = \u0026#34;\u0026#34; disabled_plugins = [] required_plugins = [] oom_score = 0 [grpc] address = \u0026#34;/run/containerd/containerd.sock\u0026#34; tcp_address = \u0026#34;\u0026#34; tcp_tls_cert = \u0026#34;\u0026#34; tcp_tls_key = \u0026#34;\u0026#34; uid = 0 gid = 0 max_recv_message_size = 16777216 max_send_message_size = 16777216 [ttrpc] address = \u0026#34;\u0026#34; uid = 0 gid = 0 [debug] address = \u0026#34;\u0026#34; uid = 0 gid = 0 level = \u0026#34;debug\u0026#34; # 开启debug [metrics] address = \u0026#34;\u0026#34; grpc_histogram = false [cgroup] path = \u0026#34;\u0026#34; [timeouts] \u0026#34;io.containerd.timeout.shim.cleanup\u0026#34; = \u0026#34;5s\u0026#34; \u0026#34;io.containerd.timeout.shim.load\u0026#34; = \u0026#34;5s\u0026#34; \u0026#34;io.containerd.timeout.shim.shutdown\u0026#34; = \u0026#34;3s\u0026#34; \u0026#34;io.containerd.timeout.task.state\u0026#34; = \u0026#34;2s\u0026#34; [plugins] [plugins.\u0026#34;io.containerd.gc.v1.scheduler\u0026#34;] pause_threshold = 0.02 deletion_threshold = 0 mutation_threshold = 100 schedule_delay = \u0026#34;0s\u0026#34; startup_delay = \u0026#34;100ms\u0026#34; [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;] disable_tcp_service = true stream_server_address = \u0026#34;127.0.0.1\u0026#34; stream_server_port = \u0026#34;0\u0026#34; stream_idle_timeout = \u0026#34;4h0m0s\u0026#34; enable_selinux = false sandbox_image = \u0026#34;k8s.gcr.io/pause:3.1\u0026#34; stats_collect_period = 10 systemd_cgroup = false enable_tls_streaming = false max_container_log_line_size = 16384 disable_cgroup = false disable_apparmor = false restrict_oom_score_adj = false max_concurrent_downloads = 3 disable_proc_mount = false [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.containerd] snapshotter = \u0026#34;overlayfs\u0026#34; default_runtime_name = \u0026#34;runc\u0026#34; no_pivot = false [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.containerd.default_runtime] runtime_type = \u0026#34;\u0026#34; runtime_engine = \u0026#34;\u0026#34; runtime_root = \u0026#34;\u0026#34; privileged_without_host_devices = false [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.containerd.untrusted_workload_runtime] runtime_type = \u0026#34;\u0026#34; runtime_engine = \u0026#34;\u0026#34; runtime_root = \u0026#34;\u0026#34; privileged_without_host_devices = false [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.containerd.runtimes] [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.containerd.runtimes.runc] runtime_type = \u0026#34;io.containerd.runc.v1\u0026#34; runtime_engine = \u0026#34;\u0026#34; runtime_root = \u0026#34;\u0026#34; privileged_without_host_devices = false [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.containerd.runtimes.kata] # 新增 runtime_type = \u0026#34;io.containerd.kata.v2\u0026#34; runtime_engine = \u0026#34;\u0026#34; runtime_root = \u0026#34;\u0026#34; privileged_without_host_devices = false [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.cni] bin_dir = \u0026#34;/opt/cni/bin\u0026#34; conf_dir = \u0026#34;/etc/cni/net.d\u0026#34; max_conf_num = 1 conf_template = \u0026#34;\u0026#34; [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.registry] [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.registry.mirrors] [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.registry.mirrors.\u0026#34;docker.io\u0026#34;] endpoint = [\u0026#34;https://registry-1.docker.io\u0026#34;] [plugins.\u0026#34;io.containerd.grpc.v1.cri\u0026#34;.x509_key_pair_streaming] tls_cert_file = \u0026#34;\u0026#34; tls_key_file = \u0026#34;\u0026#34; [plugins.\u0026#34;io.containerd.internal.v1.opt\u0026#34;] path = \u0026#34;/opt/containerd\u0026#34; [plugins.\u0026#34;io.containerd.internal.v1.restart\u0026#34;] interval = \u0026#34;10s\u0026#34; [plugins.\u0026#34;io.containerd.metadata.v1.bolt\u0026#34;] content_sharing_policy = \u0026#34;shared\u0026#34; [plugins.\u0026#34;io.containerd.monitor.v1.cgroups\u0026#34;] no_prometheus = false [plugins.\u0026#34;io.containerd.runtime.v1.linux\u0026#34;] shim = \u0026#34;containerd-shim\u0026#34; runtime = \u0026#34;runc\u0026#34; runtime_root = \u0026#34;\u0026#34; no_shim = false shim_debug = false [plugins.\u0026#34;io.containerd.runtime.v2.task\u0026#34;] platforms = [\u0026#34;linux/amd64\u0026#34;] [plugins.\u0026#34;io.containerd.service.v1.diff-service\u0026#34;] default = [\u0026#34;walking\u0026#34;] [plugins.\u0026#34;io.containerd.snapshotter.v1.devmapper\u0026#34;] root_path = \u0026#34;\u0026#34; pool_name = \u0026#34;\u0026#34; base_image_size = \u0026#34;\u0026#34; 注意： 确保containerd-shim-kata-v2 文件在 $PATH 目录下\n验证：\n# 创建容器 sudo ctr -n testns run --runtime io.containerd.kata.v2 -d --rm docker.io/library/busybox:latest busybox # 查看容器 id sudo ctr -n testns t ls # 进入容器 sudo ctr -n testns t exec -t --exec-id {ID} busybox sh # 查看内核版本 $ uname -a # 对比宿主机内核 调试 containerd-shim-runtime-v2 # containerd 配置开启 debug(需重启服务) # kata配置文件/etc/kata-containers/configuration.toml，开启 enable_debug (需重新创建安全容器) # 查看日志 $ journalctl -ft kata 附录 kata-containers 2.0 安装   下载release包\nRelease 地址\n下载 Kata Containers 2.0.0-alpha3\n解压后，拷贝至文件夹 /opt\n  准备配置文件和containerd-shim-kata-v2\n# 准备配置文件 $ cp /opt/kata/share/defaults/kata-containers/configuration-qemu.toml /etc/kata-containers/configuration.toml # 准备 containerd-shim-kata-v2 $ cp /opt/kata/bin/containerd-shim-kata-v2 /usr/local/bin/ 配置文件修改如下：\n[hypervisor.qemu] path = \u0026#34;/opt/kata/bin/qemu-system-x86_64\u0026#34; kernel = \u0026#34;/opt/kata/share/kata-containers/vmlinuz.container\u0026#34; image = \u0026#34;/opt/kata/share/kata-containers/kata-containers.img\u0026#34; machine_type = \u0026#34;pc\u0026#34; kernel_params = \u0026#34;\u0026#34; firmware = \u0026#34;\u0026#34; machine_accelerators=\u0026#34;\u0026#34; cpu_features=\u0026#34;pmu=off\u0026#34; default_vcpus = 1 default_maxvcpus = 2 default_bridges = 1 default_memory = 2048 disable_block_device_use = false shared_fs = \u0026#34;virtio-9p\u0026#34; virtio_fs_daemon = \u0026#34;/opt/kata/bin/virtiofsd\u0026#34; virtio_fs_cache_size = 1024 virtio_fs_extra_args = [] virtio_fs_cache = \u0026#34;auto\u0026#34; block_device_driver = \u0026#34;virtio-scsi\u0026#34; enable_iothreads = false enable_vhost_user_store = false vhost_user_store_path = \u0026#34;/var/run/kata-containers/vhost-user\u0026#34; enable_debug = true [factory] [agent.kata] enable_debug = true kernel_modules=[] [netmon] path = \u0026#34;/opt/kata/libexec/kata-containers/kata-netmon\u0026#34; enable_debug = true [runtime] enable_debug = true internetworking_model=\u0026#34;tcfilter\u0026#34; disable_guest_seccomp=true sandbox_cgroup_only=false experimental=[] EnablePprof = true   对接docker和containerd需要注意 注意：此版本无法与 docker配合使用，与containerd 使用正常。\n问题探讨 1.如果关闭用来开启debug console的kata-debug.service会发生什么？ 进入vm，关闭kata-debug.service，等待kata-debug.service最终停止后，重新使用socat无法再进入bash终端\nbash-4.2# systemctl stop kata-debug [ 249.392708] systemd[1]: Failed to determine peer security context: Protocol not available [ 249.394714] systemd[1]: Accepted new private connection. [ 249.395681] systemd[1]: Got unexpected auxiliary data with level=1 and type=2 [ 249.397145] systemd[1]: Got unexpected auxiliary data with level=1 and type=2 [ 249.397455] systemd[1]: Got unexpected auxiliary data with level=1 and type=2 [ 249.397759] systemd[1]: Got message type=method_call sender=n/a destination=org.freedesktop.systemd1 object=/org/freedesktop/systemd1 interface=org.freedesktop.systemd1.Manager member=StopUnit cookie=1 reply_cookie=0 error=n/a [ 249.398545] systemd[1]: Trying to enqueue job kata-debug.service/stop/replace [ 249.398983] systemd[1]: Installed new job kata-containers.target/stop as 51 [ 249.399290] systemd[1]: Installed new job kata-debug.service/stop as 50 [ 249.399604] systemd[1]: Enqueued job kata-debug.service/stop as 50 Terminated bash-4.2# systemctl status kata-debug [ 258.097267] systemd[1]: Failed to determine peer security context: Protocol not available [ 258.098268] systemd[1]: Accepted new private connection. [ 258.098453] systemd[1]: Got unexpected auxiliary data with level=1 and type=2 [ 258.098762] systemd[1]: Got unexpected auxiliary data with level=1 and type=2 [ 258.098928] systemd[1]: Got unexpected auxiliary data with level=1 and type=2 [ 258.099088] systemd[1]: Got message type=method_call sender=n/a destination=org.freedesktop.systemd1 object=/org/freedesktop/systemd1/unit/kata_2ddebug_2eservice interface=org.freedesktop.DBus.Properties member=GetAll cookie=1 reply_cookie=0 error=n/a [ 258.099783] systemd[1]: Sent message type=method_return sender=n/a destination=n/a object=n/a interface=n/a member=n/a cookie=1 reply_cookie=1 error=n/a ● kata-debug.service - Kata Containers debug console Loaded: loaded (/usr/lib/systemd/system/kata-debug.service; static; vendor preset: disabled) Active: deactivating (stop-sigterm) since Wed 2020-10-14 08:11:57 UTC; 8s ago Main PID: 57 (bash) CGroup: /system.slice/kata-debug.service ├─ 57 /bin/bash └─231 systemctl status kata-debug [ 258.101662] systemd[1]: Got disconnect on private connection. bash-4.2# system[ 339.593226] systemd[1]: kata-debug.service stop-sigterm timed out. Killing. [ 339.593989] systemd[1]: Watching 57 through watch_pids1. [ 339.594710] systemd[1]: kata-debug.service changed stop-sigterm -\u0026gt; stop-sigkill [ 339.595681] systemd[1]: Received SIGCHLD from PID 57 (bash). [ 339.596281] systemd[1]: Child 57 (bash) died (code=killed, status=9/KILL) [ 339.596722] systemd[1]: Child 57 belongs to kata-debug.service [ 339.597060] systemd[1]: Unwatching 57. [ 339.597276] systemd[1]: kata-debug.service: main process exited, code=killed, status=9/KILL [ 339.597722] systemd[1]: kata-debug.service changed stop-sigkill -\u0026gt; failed [ 339.598098] systemd[1]: Job kata-debug.service/stop finished, result=done # 此处kata-debug.service完全退出，无法再进入终端 # 尝试重新进入终端，会发现回车后无法打开bash终端 root@zbb-pc:/run/vc/vm/d658a67be082b2952c360e7539b5bfa7ac744ae8b84d844d57547d36915e184f# socat \u0026#34;stdin,raw,echo=0,escape=0x11\u0026#34; \u0026#34;unix-connect:./console.sock\u0026#34; # 重启容器后，可重新进入终端 # 此处发现重启容器过程，其实是新建一个同名的容器，因为会发现vm原有目录文件均被删除，生成同名文件夹。如果查看前后vm目录，应该文件inode已产生变化。 ","date":"2020-07-25T23:06:12+08:00","permalink":"https://bevisy.github.io/p/kata-containers-compile-and-installed/","title":"Kata-containers Compile And Installed"},{"content":"Compile qemu on Ubuntu 20.04 下载源码 git clone https://git.qemu.org/git/qemu.git cd qemu git submodule init git submodule update --recursive 编译安装 ./configure make 问题 # ERROR: glib-2.48 gthread-2.0 is required to compile QEMU $ sudo apt install -y libglib2.0-dev # ERROR: pixman \u0026gt;= 0.21.8 not present. # Please install the pixman devel package. $ sudo apt install -y libpixman-1-dev ","date":"2020-07-24T22:21:51+08:00","permalink":"https://bevisy.github.io/p/compile-qemu-on-ubuntu-20.04/","title":"Compile qemu on Ubuntu 20.04"},{"content":"VIM 使用技巧 查找 大小写敏感控制 # VIM 默认大小写敏感查找； # 大小写不敏感查找 ：/foo\\c # 大小写敏感查找 ：/foo\\C 查找光标当前单词 # normal 模式下，\u0026#34;*\u0026#34; 键查找当前单词 Vim 查找和替换 :{作用范围}s/{目标}/{替换}/{替换标志} # 当前行替换 ：s/vivian/sky/ 替换当前行第一个 vivian 为 sky ：s/vivian/sky/g 替换当前行所有 vivian 为 sky # 范围替换； n 为数字，若 n 为 .，表示从当前行开始到最后一行  ：n,$s/vivian/sky/ 替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky ：n,$s/vivian/sky/g 替换第 n 行开始到最后一行中每一行所有 vivian 为 sky ：2,12s/hello/world/ 2-12行,第一次出现替换 ：.,+2s/hello/world/ 当前行与接下来的2行，第一次出现替换 # 全行替换 ：%s/vivian/sky/（等同于 ：g/vivian/s//sky/） 替换每一行的第一个 vivian 为 sky ：%s/vivian/sky/g（等同于 ：g/vivian/s//sky/g） 替换每一行中所有 vivian 为 sky # 使用\u0026#34;#\u0026#34;作为分隔符，此时中间出现的 / 不会作为分隔符  ：s#vivian/#sky/# 替换当前行第一个 vivian/ 为 sky/ ：%s+/oradata/apras/+/user01/apras1+ （使用+ 来 替换 / ）： /oradata/apras/替换成/user01/apras1/ # 替换确认，添加参数c，提示是否替换 :%s/hello/world/gc 针对每一个匹配项，提示是否替换 ","date":"2020-07-24T15:02:12+08:00","permalink":"https://bevisy.github.io/p/the-skills-of-vim/","title":"The Skills of VIM"},{"content":"Linux 内核编译(Ubuntu 环境) 下载内核代码 https://www.kernel.org/\n安装依赖 sudo apt update sudo apt install -y \\ \tgcc \\ \tmake \\ \tlibncurses5-dev \\ \topenssl \\ \tlibssl-dev \\ \tbuild-essential \\ \tpkg-config \\ \tlibc6-dev \\ \tbison \\ \tflex \\ \tlibelf-dev 准备.config和自定义配置 cd {Download}/linux-5.4.32/ sudo cp /boot/config-{uname -r} .config sudo make menuconfig 编译内核 # 编译内核 sudo make sudo make modules_install 安装内核 sudo mv {Download}/linux-5.4.32 /usr/src/ cd /usr/src/linux-5.4.32/ sudo make install sudo mkinitramfs -o /boot/initrd.img-5.4.32 sudo update-initramfs -c -k 5.4.32 sudo update-grub2 验证 sudo reboot uname -a ","date":"2020-07-24T00:41:59+08:00","permalink":"https://bevisy.github.io/p/compile-linux-kernel-on-ubuntu-20.04/","title":"Compile Linux Kernel on Ubuntu 20.04"},{"content":"zsh 安装总结 安装zsh # Ubuntu 18.04 sudo apt update sudo apt install zsh -y 安装 Oh My Zsh # https://ohmyz.sh/#install sh -c \u0026#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 插件安装 # 使用 Oh My Zsh 安装插件；默认安装目录为 $ZSH_CUSTOM/plugins (by default ~/.oh-my-zsh/custom/plugins) git clone https://github.com/zsh-users/zsh-autosuggestions.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting # 配置 .zshrc，添加插件列表 plugins=(zsh-autosuggestions zsh-syntax-highlighting) # 启动新终端，查看效果示例 zsh ","date":"2020-07-18T12:14:33+08:00","permalink":"https://bevisy.github.io/p/zsh-and-oh-my-zsh-installation-summary/","title":"Zsh-And-Oh My Zsh-Installation summary"},{"content":"nginx 代理 netdata 并添加鉴权 netdata 安装 #!/bin/bash  docker run -d --name=netdata \\  -p 30002:19999 \\  -v /etc/passwd:/host/etc/passwd:ro \\  -v /etc/group:/host/etc/group:ro \\  -v /proc:/host/proc:ro \\  -v /sys:/host/sys:ro \\  -v /var/run/docker.sock:/var/run/docker.sock:ro \\  -e DO_NOT_TRACK=1 \\  --cap-add SYS_PTRACE \\  --security-opt apparmor=unconfined \\  netdata/netdata nginx 安装 #!/usr/bin/env bash  docker run -d \\  --name nginx \\  -v $(pwd)/html:/usr/share/nginx/html \\  -v $(pwd)/conf.d:/etc/nginx/conf.d \\  -v $(pwd)/ssl:/etc/nginx/ssl \\  -v $(pwd)/passwords:/etc/nginx/passwords \\  -p 8080:80 \\  -p 8443:443 \\  -e TZ=\u0026#34;Asia/Chongqing\u0026#34; \\  nginx # 需要准备的文件 . ├── conf.d │ └── default.conf ├── html │ ├── 50x.html │ └── index.html ├── nginx-start.sh ├── passwords └── ssl ├── nginx.crt └── nginx.key nginx 配置 upstream netdata { server 192.168.124.2:19999; keepalive 64; } server { listen 80; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm; } location = /netdata { return 301 /netdata/; } location ~ /netdata/(?\u0026lt;ndpath\u0026gt;.*) { proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_pass_request_headers on; proxy_set_header Connection \u0026#34;keep-alive\u0026#34;; proxy_store off; proxy_pass http://netdata/$ndpath$is_args$args; gzip on; gzip_proxied any; gzip_types *; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache\u0026#39;s document root # concurs with nginx\u0026#39;s one # #location ~ /\\.ht { # deny all; #} } server { listen 443 ssl; ssl_certificate /etc/nginx/ssl/nginx.crt; ssl_certificate_key /etc/nginx/ssl/nginx.key; keepalive_timeout 60; server_name localhost; server_tokens off; fastcgi_param HTTPS on; fastcgi_param HTTP_SCHEME https; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; location / { root /usr/share/nginx/html/; index index.html index.htm; } location = /netdata { return 301 /netdata/; } location ~ /netdata/(?\u0026lt;ndpath\u0026gt;.*) { proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_pass_request_headers on; proxy_set_header Connection \u0026#34;keep-alive\u0026#34;; proxy_store off; proxy_pass http://netdata/$ndpath$is_args$args; gzip on; gzip_proxied any; gzip_types *; } } 访问nginx http://nginxurl:80/netdata/ 或者 https://nginxurl:443/netdata/，验证生效。\n生成 ssl 证书和密钥 # 有效时间 7 天 openssl req -x509 -nodes -days 7 -newkey rsa:2048 -keyout /etc/nginx/ssl/nginx.key -out /etc/nginx/ssl/nginx.crt -subj \u0026#34;/C=CN/ST=SiChuan/L=Chengdu/O=Example Inc./OU=Web Security/CN=localhost\u0026#34; 生成的证书未经权威机构认证，但是不影响使用，只是浏览器会提示非安全的证书。\nnginx 配置https 服务 server { listen 443 ssl; ssl_certificate /etc/nginx/ssl/nginx.crt; ssl_certificate_key /etc/nginx/ssl/nginx.key; keepalive_timeout 60; server_name localhost; server_tokens off; fastcgi_param HTTPS on; fastcgi_param HTTP_SCHEME https; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; location / { root /usr/share/nginx/html/; index index.html index.htm; } location = /netdata { return 301 /netdata/; } location ~ /netdata/(?\u0026lt;ndpath\u0026gt;.*) { proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_pass_request_headers on; proxy_set_header Connection \u0026#34;keep-alive\u0026#34;; proxy_store off; proxy_pass http://netdata/$ndpath$is_args$args; gzip on; gzip_proxied any; gzip_types *; } } nginx 添加鉴权 nginx 目前开启的是全局 ssl ，即通过 443 端口进入的请求均为 https，但是upstream 上的服务依旧是 http。\n创建认证文件，开启 nginx 基础认证 # 提示输入密码和确认密码 printf \u0026#34;username:$(openssl passwd -apr1)\u0026#34; \u0026gt; /etc/nginx/passwords 在 server directive 中开启认证 server { listen 443 ssl; # ... auth_basic \u0026#34;Protected\u0026#34;; auth_basic_user_file passwords; # ... access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; } HTTP 自动跳转HTTPS 安全配置 参考 Nginx 服务器证书安装\nserver { listen 443; #填写绑定证书的域名 server_name www.domain.com; ssl on; #网站主页路径。此路径仅供参考，具体请您按照实际目录操作。 root /var/www/www.domain.com; index index.html index.htm; #证书文件名称 ssl_certificate 1_www.domain.com_bundle.crt; #私钥文件名称 ssl_certificate_key 2_www.domain.com.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { index index.html index.htm; } } server { listen 80; #填写绑定证书的域名 server_name www.domain.com; #把http的域名请求转成https rewrite ^(.*)$ https://$host$1 permanent; } 使用权威机构签名证书 查看证书内容 openssl x509 -in nginx.crt -noout -text 查看key内容 openssl rsa -in nginx.key -noout -text 申请腾讯云免费SSL证书 腾讯云免费ssl证书申请\nReference Running Netdata behind Nginx\nEnabling TLS support\nNginx 服务器证书安装\n","date":"2020-01-21T15:56:21+08:00","permalink":"https://bevisy.github.io/p/%E9%80%9A%E8%BF%87nginx%E4%B8%BAnetdata%E6%8F%90%E4%BE%9Bhttps%E8%AE%BF%E9%97%AE/","title":"通过nginx为netdata提供https访问"},{"content":"Travis CI 部署 Hexo 生成文件到 master 分支 文档主要实现Hexo利用 Travis CI 完成 github page 部署。\n由于 username.github.io 仓库不允许切换 github page 分支，必须将 master 分支作为静态资源分支，所以新建 develop 分支作为开发分支。\n详细的步骤参考将 Hexo 部署到 GitHub Pages，此处主要贴出区别的 Travis CI 配置文件：\nsudo: false language: node_js node_js: - 13.6.0 cache: npm branches: only: - develop script: - hexo generate deploy: provider: pages skip-cleanup: true github-token: $GH_TOKEN keep-history: false target_branch: master local-dir: public on: branch: develop 上述配置信息解释参考 GitHub Pages Deployment。\n参考文档 GitHub Pages Deployment\n将 Hexo 部署到 GitHub Pages\n","date":"2020-01-21T00:25:33+08:00","permalink":"https://bevisy.github.io/p/%E9%80%9A%E8%BF%87travis-ci-%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%B0-github-page/","title":"通过Travis CI 部署静态页面到 github page"}]